#!/usr/bin/env Rscript

NEEDARGS = 2

# get current script dir
self.name = substring(grep("^--file=", commandArgs(), value = TRUE), 8)
scriptdir = dirname(self.name)
# if we were not called with Rscript, then scriptdir is empty--fall back to "."
scriptdir = c(scriptdir, ".")[1]
# load common configuration
source(file.path(scriptdir, "buildheader.R"), chdir = TRUE)

# worker function
knitIt = function(infile, outfile) {
  loadlibraries()

  f = basename(infile)
  messagef("Knitting file '%s' ...", infile)
  lines = readLines(infile)

  dev = c("pdf", "svg")
  knit.params = knit_params(lines)
  if (isTRUE(knit.params$run.for.each.dev$value)) {
    dev = "pdf"
  }

  # apply replacement macros
  for (macro in macros) {
    lines = str_replace_all(lines, macro$pattern, macro$replacement)
  }

  cache.path = file.path("cache", f, "")
  opts_chunk$set(cache = TRUE, cache.path = cache.path, fig.path = file.path("figure", str_replace(f, "\\.Rmd", ""), ""),
    dev = dev, error = FALSE, comment = "#>", collapse = TRUE)
  setSeed(f)

  # FIXME: remove if mkdocs handles this, currently mkdocs puts yaml front matter in the output.
  yaml.lines = which(lines == "---")
  if (length(yaml.lines == 2)) {
    lines = lines[-1 * seq(from = yaml.lines[1], to = yaml.lines[2])]
  }

  # write to a temporary file first, then move to actual target file after success.
  # This is necessary to prevent half-completed files to be written when knitting fails.
  tmpoutput = paste0(outfile, ".tmp")

  knit(
    text = lines,
    output = tmpoutput,
    quiet = TRUE
  )

  file.rename(tmpoutput, outfile)
  invisible(NULL)
}

knitIt(argv[1], argv[2])
